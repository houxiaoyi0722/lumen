### flowable表结构解释

- ACT_RE ：'RE'表示 repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。
- ACT_RU：'RU'表示 runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Flowable只在流程实例执行过程中保存这些数据，
  在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。
- ACT_HI：'HI'表示 history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。
- ACT_GE： GE 表示 general。 通用数据， 用于不同场景下
- ACT_ID:   ’ID’表示identity(组织机构)。这些表包含标识的信息，如用户，用户组，等等。

具体的表结构的含义:
表分类表名解释

| 表名                  | Description               |
|---------------------|---------------------------|
| 一般数据                |
| ACT_GE_BYTEARRAY    | 通用的流程定义和流程资源              |
| ACT_GE_PROPERTY     | 系统相关属性                    |
| 流程历史记录              |
| ACT_HI_ACTINST      | 历史的流程实例                   |
| ACT_HI_ATTACHMENT   | 历史的流程附件                   |
| ACT_HI_COMMENT      | 历史的说明性信息                  |
| ACT_HI_DETAIL       | 历史的流程运行中的细节信息             |
| ACT_HI_IDENTITYLINK | 历史的流程运行过程中用户关系            |
| ACT_HI_PROCINST     | 历史的流程实例                   |
| ACT_HI_TASKINST     | 历史的任务实例                   |
| ACT_HI_VARINST      | 历史的流程运行中的变量信息             |
| 流程定义表               |
| ACT_RE_DEPLOYMENT   | 部署单元信息                    |
| ACT_RE_MODEL        | 模型信息                      |
| ACT_RE_PROCDEF      | 已部署的流程定义                  |
| 运行实例表               |
| ACT_RU_EVENT_SUBSCR | 运行时事件                     |
| ACT_RU_EXECUTION    | 运行时流程执行实例                 |
| ACT_RU_IDENTITYLINK | 运行时用户关系信息，存储任务节点与参与者的相关信息 |
| ACT_RU_JOB          | 运行时作业                     |
| ACT_RU_TASK         | 运行时任务                     |
| ACT_RU_VARIABLE     | 运行时变量表                    |
| 用户用户组表              |
| ACT_ID_BYTEARRAY    | 二进制数据表                    |
| ACT_ID_GROUP        | 用户组信息表                    |
| ACT_ID_INFO         | 用户信息详情表                   |
| ACT_ID_MEMBERSHIP   | 人与组关系表                    |
| ACT_ID_PRIV         | 权限表                       |
| ACT_ID_PRIV_MAPPING | 用户或组权限关系表                 |
| ACT_ID_PROPERTY     | 属性表                       |
| ACT_ID_TOKEN        | 记录用户的token信息              |
| ACT_ID_USER         | 用户表                       |

### Service总览

| service名称         | service作用        |
|-------------------|------------------|
| RepositoryService | Flowable的资源管理类   |
| RuntimeService    | Flowable的流程运行管理类 |
| TaskService       | Flowable的任务管理类   | 
| HistoryService    | Flowable的历史管理类   |
| ManagerService    | Flowable的引擎管理类   |

### 事件类型

然后在FlowableUI中关联对应的监听器

- create:任务创建后触发
- assignment:任务分配后触发
- Delete:任务完成后触发
- All：所有事件都触发

### 网管

- 排他网关

> 排他网关（exclusive gateway）（也叫异或网关 XOR gateway，或者更专业的，基于数据的排他网关 exclusive data-based
> gateway），用于对流程中的决策建模。当执行到达这个网关时，会按照所有出口顺序流定义的顺序对它们进行计算。选择第一个条件计算为true的顺序流（当没有设置条件时，认为顺序流为true）继续流程。
> 请注意这里出口顺序流的含义与BPMN
> 2.0中的一般情况不一样。一般情况下，会选择所有条件计算为true的顺序流，并行执行。而使用排他网关时，只会选择一条顺序流。当多条顺序流的条件都计算为true时，会且仅会选择在XML中最先定义的顺序流继续流程。如果没有可选的顺序流，会抛出异常。
> 图示 排他网关用内部带有’X’图标的标准网关（菱形）表示，'X’图标代表异或的含义。请注意内部没有图标的网关默认为排他网关。BPMN
> 2.0规范不允许在同一个流程中混合使用有及没有X的菱形标志。

> 如果从网关出去的线所有条件都不满足的情况下会抛出系统异常，
> 但是要注意任务没有结束，还是原来的任务，我们可以重置流程变量

- 并行网关

> 并行网关允许将流程分成多条分支，也可以把多条分支汇聚到一起，并行网关的功能是基于进入和外出顺序流的：
> fork分支：并行后的所有外出顺序流，为每个顺序流都创建一个并发分支。
> join汇聚： 所有到达并行网关，在此等待的进入分支， 直到所有进入顺序流的分支都到达以后， 流程就会通过汇聚网关。
注意，如果同一个并行网关有多个进入和多个外出顺序流， 它就同时具有分支和汇聚功能。 这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支。
与其他网关的主要区别是，并行网关不会解析条件。 即使顺序流中定义了条件，也会被忽略。

- 包含网关
> 包含网关可以看做是排他网关和并行网关的结合体。 和排他网关一样，你可以在外出顺序流上定义条件，包含网关会解析它们。 但是主要的区别是包含网关可以选择多于一条顺序流，这和并行网关一样。
包含网关的功能是基于进入和外出顺序流的：
> 分支： 所有外出顺序流的条件都会被解析，结果为true的顺序流会以并行方式继续执行， 会为每个顺序流创建一个分支。
> 汇聚：所有并行分支到达包含网关，会进入等待状态， 直到每个包含流程token的进入顺序流的分支都到达。 这是与并行网关的最大不同。换句话说，包含网关只会等待被选中执行了的进入顺序流。 在汇聚之后，流程会穿过包含网关继续执行。

- 事件网关
> 事件网关允许根据事件判断流向。网关的每个外出顺序流都要连接到一个中间捕获事件。 当流程到达一个基于事件网关，网关会进入等待状态：会暂停执行。与此同时，会为每个外出顺序流创建相对的事件订阅。
  事件网关的外出顺序流和普通顺序流不同，这些顺序流不会真的"执行"， 相反它们让流程引擎去决定执行到事件网关的流程需要订阅哪些事件。 要考虑以下条件：
> 事件网关必须有两条或以上外出顺序流；
> 事件网关后，只能使用intermediateCatchEvent类型（activiti不支持基于事件网关后连接ReceiveTask）
> 连接到事件网关的中间捕获事件必须只有一个入口顺序流


### 事件

> 事件（event）通常用于为流程生命周期中发生的事情建模。事件总是图形化为圆圈。在BPMN 2.0中，有两种主要的事件分类：*捕获（catching）与抛出（throwing）*事件。

- 捕获: 当流程执行到达这个事件时，会等待直到触发器动作。触发器的类型由其中的图标，或者说XML中的类型声明而定义。捕获事件与抛出事件显示上的区别，是其内部的图标没有填充（即是白色的）。
- 抛出: 当流程执行到达这个事件时，会触发一个触发器。触发器的类型，由其中的图标，或者说XML中的类型声明而定义。抛出事件与捕获事件显示上的区别，是其内部的图标填充为黑色

#### 定时事件
定时触发的相关事件，包括定时器启动事件，定时器捕获中间件事件，定时器边界事件
> *** 定时器必须开启异步任务才会创建 ***
##### 定时器启动事件

> 定时器启动事件（timer start event）在指定时间创建流程实例。在流程只需要启动一次，或者流程需要在特定的时间间隔重复启动时，都可以使用。
*请注意：*子流程不能有定时器启动事件。
*请注意：*定时器启动事件，在流程部署的同时就开始计时。不需要调用startProcessInstanceByXXX就会在时间启动。调用startProcessInstanceByXXX时会在定时启动之外额外启动一个流程。
*请注意：*当部署带有定时器启动事件的流程的更新版本时，上一版本的定时器作业会被移除。这是因为通常并不希望旧版本的流程仍然自动启动新的流程实例。
定时器启动事件，用其中有一个钟表图标的圆圈来表示。

##### 定时器捕获中间事件

##### 定时器边界事件


> 循环设定
- 启动事件：根据设置循环启动流程实例
- 中间事件：即使设置了循环时间也只会触发异常
- 边界事件：即使设置了循环时间也只会触发异常
